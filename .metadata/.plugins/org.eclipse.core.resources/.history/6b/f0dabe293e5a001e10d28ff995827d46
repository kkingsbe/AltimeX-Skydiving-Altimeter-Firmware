/*
 * altimex.cpp
 *
 *  Created on: Sep 23, 2023
 *      Author: kking
 */
#include "altimex.h"

Altimex::Altimex(UART_HandleTypeDef* _uart, I2C_HandleTypeDef* i2c_config, TIM_HandleTypeDef* _timer):
	ledController(new AltimexLedController(&config, _timer)),
	stateController(new AltimexStateController(&config)),
	tempF(0.0),
	alt(0.0)
{
	STM_USB::init(_uart);
	char message[] = "AltimeX Boot...";
	STM_USB::println(message, strlen(message));
	LPS22HB* barometer = new LPS22HB(i2c_config, LPS_DEFAULT_ADDRESS);
	LPS22HB::LPS_INIT_STATUS baro_init_status = barometer->init();

	if(baro_init_status != LPS22HB::LPS_INIT_STATUS::SUCCESS) {
		while(true) {
			char message[] = "Error while initializing sensor.";
			STM_USB::println(message, strlen(message));
			HAL_Delay(1000);
		}
	}

	barometer->calibrate(10, 100);
	tempF = barometer->get_tempf();

	struct AltimexConfig config;
	config.ascentThreshold = 500;              //The altitude you must pass for it to transition into the ascent state
	config.ascentThresholdTime = 1000;         //ms that altitude must be above the ascentThreshold before transitioning between states
	config.deployTestThresholdTime = 2000;     //ms, threshold time that vertical speed has to be under 50mph
	config.gearCheckNotificationLength = 5000; //ms, the length of the gearcheck notification
	config.freefallThresholdTime = 2000;       //ms, the amount of time that the vertical speed must be above the freefall threshold speed to transition into freefall state
	config.exit = 12500.0;                     //Exit altitude
	config.breakoff = 5500.0;                  //Breakoff altitude
	config.deploy = 4500.0;                    //Deployment altitude
	config.standbyFlashOnLength = 100;         //How long the light is on for when in standby mode
	config.standbyFlashOffLength = 10000;      //Period between each flash in standby mode
	config.numLeds = 10;                       //The number of leds being used
	config.gearCheckAlt = 10000.0;             //The altitude that the gear check notification is given
	config.brightness = 20;                    //LED brightness
	config.standbyBrightness = 5;              //Brightness of LEDS while in standby mode
}

void Altimex::tick()
{
	//STORAGE_write(&hi2c1, 0, 8, &data);
	//uint8_t data_read[8] = {'\0'};
	//STORAGE_read(&hi2c1, 0, 8, &data_read);
	//println(data_read, strlen(data_read), &huart1);

	tempF = barometer->get_tempf();
	STM_USB::printd(tempF);
	  /*
	  if(HAL_GetTick() > 10000 && HAL_GetTick() < 70000) alt = ((HAL_GetTick() - 10000) / (double)60000) * 12500;
	  if(alt < 0) alt = 12500;
	  if(HAL_GetTick() > 70000)
	  {
		if(alt < 2500) alt -= 5;
		else alt -= 29;
	  }
	*/

	  alt = barometer->get_relalt_ft();
	  stateController->update_state(alt);
	  ledController->display_leds(stateController->get_state(), step, alt);
	  step++;
	  if(step > 100) step = 0;

	  /*
	  char data[10];
	  sprintf(data, "%f", alt);
	  HAL_UART_Transmit(&huart1, data, sizeof(data), 100);
	  */

	  //printd(alt, &huart1);

	  //Data is received one byte at a time
	  //uint8_t Rx_data[1];
	  //HAL_UART_Receive(&huart1, Rx_data, 100, 100);

	  HAL_Delay(100); //10hz
}
